<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>ROP.Micro</name></assembly>
<members>
<member name="T:ROP.Micro.TwoTrack`2">
<summary>
 Two-track type
</summary>
</member>
<member name="M:ROP.Micro.plus``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``3,Microsoft.FSharp.Core.FSharpFunc{``3,``3}},Microsoft.FSharp.Core.FSharpFunc{``4,ROP.Micro.TwoTrack{``0,``3}},Microsoft.FSharp.Core.FSharpFunc{``4,ROP.Micro.TwoTrack{``1,``3}},``4)">
<summary>
 Add two switches in parallel
</summary>
</member>
<member name="M:ROP.Micro.doubleMap``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``3})">
<summary>
 Convert two one-track functions into a two-track function
</summary>
</member>
<member name="M:ROP.Micro.tryCatch``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{System.Exception,``2},``0)">
<summary>
 Convert a one-track function into a switch with exception handler
</summary>
</member>
<member name="M:ROP.Micro.tee``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},``0)">
<summary>
 Convert a dead-end function into a one-track function
</summary>
</member>
<member name="M:ROP.Micro.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Convert a one-track function into a two-track function
</summary>
</member>
<member name="M:ROP.Micro.switch``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Convert a one-track function into a switch
</summary>
</member>
<member name="M:ROP.Micro.op_GreaterEqualsGreater``4(Microsoft.FSharp.Core.FSharpFunc{``0,ROP.Micro.TwoTrack{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``1,ROP.Micro.TwoTrack{``3,``2}})">
<summary>
 Compose two switches into another switch
</summary>
</member>
<member name="M:ROP.Micro.op_GreaterGreaterEquals``3(ROP.Micro.TwoTrack{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,ROP.Micro.TwoTrack{``2,``1}})">
<summary>
 Pipe a two-track value into a switch function 
</summary>
</member>
<member name="M:ROP.Micro.bind``3(Microsoft.FSharp.Core.FSharpFunc{``0,ROP.Micro.TwoTrack{``1,``2}})">
<summary>
 Convert a switch function into a two-track function
</summary>
</member>
<member name="M:ROP.Micro.either``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``1},ROP.Micro.TwoTrack{``0,``2})">
<summary>
 Apply either a success or failure function
</summary>
</member>
<member name="M:ROP.Micro.fail``2(``0)">
<summary>
 Convert a single value into a Failure two-track result
</summary>
</member>
<member name="M:ROP.Micro.succeed``2(``0)">
<summary>
 Convert a single value into a two-track Success result
</summary>
</member>
<member name="T:ROP.Micro">
<summary>
 Use TwoTrack type as your underlying model for dataflow situations.
 Create a function for each step in the use case. 
 The function for each step can in turn be built from smaller functions.
 Use standard composition (&gt;&gt;) to connect the functions.
 If you need to insert a switch into the flow, use bind.
 If you need to insert a single-track function into the flow, use map.
 If you need to insert other types of functions into the flow, create an appropriate adapter block and use it. 
</summary>
</member>
</members>
</doc>
