<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>ROP.Micro</name></assembly>
<members>
<member name="T:ROP.Micro.TwoTrack`2">
<summary>
 Two-track type
</summary>
</member>
<member name="M:ROP.Micro.Operators.op_GreaterEqualsGreater``4(Microsoft.FSharp.Core.FSharpFunc{``0,ROP.Micro.TwoTrack{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``1,ROP.Micro.TwoTrack{``3,``2}})">
<summary>
 Compose two switches into another switch
</summary>
</member>
<member name="M:ROP.Micro.Operators.op_GreaterGreaterEquals``3(ROP.Micro.TwoTrack{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,ROP.Micro.TwoTrack{``2,``1}})">
<summary>
 Pipe a two-track value into a switch function 
</summary>
</member>
<member name="T:ROP.Micro.Operators">
<summary>
 (&gt;&gt;=) Pipe a two-track value into a switch function.
 (&gt;=&gt;) Compose two switches into another switch.
</summary>
</member>
<member name="M:ROP.Micro.Rop.valueOrDefault``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},ROP.Micro.TwoTrack{``1,``0})">
<summary>
 given an two-trakc result, in the success case, return the value.
 In the failure case, determine the value to return by 
 applying a function to the error in the failure case
</summary>
</member>
<member name="M:ROP.Micro.Rop.plus``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``3,Microsoft.FSharp.Core.FSharpFunc{``3,``3}},Microsoft.FSharp.Core.FSharpFunc{``4,ROP.Micro.TwoTrack{``0,``3}},Microsoft.FSharp.Core.FSharpFunc{``4,ROP.Micro.TwoTrack{``1,``3}},``4)">
<summary>
 Add two switches in parallel
</summary>
</member>
<member name="M:ROP.Micro.Rop.doubleMap``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``3})">
<summary>
 Convert two one-track functions into a two-track function
</summary>
</member>
<member name="M:ROP.Micro.Rop.tryCatchAsync``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Core.FSharpFunc{System.Exception,``2},``0)">
<summary>
 Execute an async function (with exception handler) then convert into a two-track result
</summary>
</member>
<member name="M:ROP.Micro.Rop.tryCatch``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{System.Exception,``2},``0)">
<summary>
 Convert a one-track function into a switch with exception handler
</summary>
</member>
<member name="M:ROP.Micro.Rop.tee``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},``0)">
<summary>
 Convert a dead-end function into a one-track function
</summary>
</member>
<member name="M:ROP.Micro.Rop.liftOption``2(Microsoft.FSharp.Core.FSharpOption{``0},``1)">
<summary>
 Convert an option into a two-track function
</summary>
</member>
<member name="M:ROP.Micro.Rop.liftChoice``2(Microsoft.FSharp.Core.FSharpChoice{``0,``1})">
<summary>
 Convert a choice into a two-track function
</summary>
</member>
<member name="M:ROP.Micro.Rop.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Convert a one-track function into a two-track function
</summary>
</member>
<member name="M:ROP.Micro.Rop.switch``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Convert a one-track function into a switch
</summary>
</member>
<member name="M:ROP.Micro.Rop.bind``3(Microsoft.FSharp.Core.FSharpFunc{``0,ROP.Micro.TwoTrack{``1,``2}})">
<summary>
 Convert a switch function into a two-track function
</summary>
</member>
<member name="M:ROP.Micro.Rop.either``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``1},ROP.Micro.TwoTrack{``0,``2})">
<summary>
 Apply either a success or failure function
</summary>
</member>
<member name="M:ROP.Micro.Rop.fail``2(``0)">
<summary>
 Convert a single value into a Failure two-track result
</summary>
</member>
<member name="M:ROP.Micro.Rop.succeed``2(``0)">
<summary>
 Convert a single value into a two-track Success result
</summary>
</member>
<member name="T:ROP.Micro.Rop">
<summary>
 Use TwoTrack type as your underlying model for dataflow situations.
 Create a function for each step in the use case. 
 The function for each step can in turn be built from smaller functions.
 Use standard composition (&gt;&gt;) to connect the functions.
 If you need to insert a switch into the flow, use bind.
 If you need to insert a single-track function into the flow, use map.
 If you need to insert other types of functions into the flow, create an appropriate adapter block and use it. 
</summary>
</member>
</members>
</doc>
